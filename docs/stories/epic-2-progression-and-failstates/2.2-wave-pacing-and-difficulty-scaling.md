# Godot Story: Wave Pacing & Difficulty Scaling

**Epic:** Epic 2 – Failure Handling & Progression Scaling  
**Story ID:** 2.2  
**Priority:** High  
**Points:** 8  
**Status:** Approved
**Language:** GDScript  
**Performance Target:** 60+ FPS

## Description
Implement wave-based pacing that adjusts spawn cadence, patience multipliers, and cabinet clutter as sessions progress. The system reads `WaveConfig` resources, applies difficulty curves to queue timing, and validates telemetry so frame time stays within budget. [Source: game-prd/requirements.md#functional][Source: architecture/game-systems-components.md#core-systems][Source: architecture/game-data-models.md#game-data-models]

**Godot Implementation:** Extend `WaveController`, `OrderService`, and `CabinetItemPool` to consume difficulty curves, while `SessionHUD` and analytics log progression data for balancing. [Source: architecture/gameplay-systems-architecture.md#gameplay-components][Source: architecture/node-architecture-details.md#resource-architecture][Source: architecture/analytics-integration.md#event-design]

**Performance Impact:** Apply pacing updates via precomputed curves, reuse pooled clutter, and profile each wave to maintain <16.67 ms frame time and <1.4 GB memory. [Source: architecture/performance-and-security-considerations.md#performance-budgets][Source: architecture/rendering-pipeline-configuration.md#rendering-optimization][Source: architecture/node-architecture-details.md#node-patterns]

## Acceptance Criteria
### Functional Requirements
- `WaveController` loads `WaveConfig` resources and schedules spawn intervals and patience multipliers per wave. [Source: architecture/game-systems-components.md#core-systems][Source: architecture/game-data-models.md#game-data-models]
- Cabinet clutter level adjusts via pooled seafood descriptors, increasing item density as waves progress. [Source: architecture/gameplay-systems-architecture.md#gameplay-components][Source: architecture/node-architecture-details.md#node-patterns]
- Difficulty metrics (wave index, patience multiplier, clutter level) logged to analytics after each wave. [Source: architecture/analytics-integration.md#event-design]
- HUD wave progress bar reflects pacing changes and warns players when spawn cadence increases. [Source: front-end-spec.md#session_hudtscn][Source: architecture/ui-component-system.md#data-binding]

### Technical Requirements
- Typed GDScript for wave logic; no runtime resource lookups inside frame-critical loops. [Source: architecture/godot-development-conventions.md#best-practices][Source: architecture/node-architecture-details.md#resource-architecture]
- Maintains 60+ FPS and <16.67 ms frame time even at maximum clutter. [Source: architecture/performance-and-security-considerations.md#performance-budgets]
- Object pooling expanded for additional seafood and debris. [Source: architecture/node-architecture-details.md#node-patterns]
- Signals ensure wave transitions trigger exactly once; no duplication. [Source: architecture/game-systems-components.md#system-interaction-wave-flow]
- GUT coverage ≥ 80% for wave scheduling methods. [Source: architecture/test-strategy-and-standards.md#testing-philosophy]
- Clutter adjustments respect memory budgets (<1.4 GB iOS / 1.6 GB Android). [Source: architecture/performance-and-security-considerations.md#performance-budgets]

### Game Design Requirements
- Difficulty ramp matches designer curves, providing noticeable pressure without unfair spikes. [Source: docs/game-prd/epics/epic-2-progression-and-failstates.md#description][Source: architecture/game-data-models.md#game-data-models]
- Cabinet clutter changes remain visually readable and respect cozy art style. [Source: architecture/rendering-pipeline-configuration.md#render-pipeline-setup][Source: game-prd/goals-and-background-context.md#goals]
- Wave summary messaging communicates pace changes and upcoming challenges. [Source: front-end-spec.md#fulfill-customer-order-during-score-run][Source: architecture/ui-component-system.md#data-binding]

## Technical Specifications
### Files to Create/Modify
**New Scripts:**
- `res://scripts/services/wave_controller.gd` – Applies `WaveConfig` curves, schedules spawn timers, and publishes wave transition signals. [Source: architecture/game-systems-components.md#core-systems][Source: architecture/game-data-models.md#game-data-models]
- `res://scripts/ui/wave_progress_panel.gd` – Renders progress, upcoming difficulty hints, and warning animations. [Source: front-end-spec.md#session_hudtscn][Source: architecture/ui-component-system.md#data-binding]

**Modified Files:**
- `res://autoload/OrderService.gd` – Respect wave multipliers for patience and scoring. [Source: architecture/game-systems-components.md#core-systems]
- `res://scripts/gameplay/customer_queue.gd` – Consume wave cadence data to adjust spawn intervals. [Source: architecture/gameplay-systems-architecture.md#gameplay-components]
- `res://scripts/gameplay/cabinet_item_pool.gd` – Load clutter presets, ensure pooling covers maximum density. [Source: architecture/node-architecture-details.md#node-patterns]
- `res://scripts/ui/session_hud.gd` – Display wave index, difficulty warnings, and update progress bar. [Source: front-end-spec.md#session_hudtscn]
- `res://scripts/services/analytics_stub.gd` – Log wave pacing metrics. [Source: architecture/analytics-integration.md#event-design]
- `res://resources/data/wave_config.tres` – Author designer curves for spawn cadence, patience multipliers, clutter levels. [Source: architecture/game-data-models.md#game-data-models]

### Node/Class Definitions
**GDScript Implementation (for game logic):**
```gdscript
# wave_controller.gd
class_name WaveController
extends Node

@export var wave_config: WaveConfig
@export var queue: CustomerQueue

@onready var _signal_hub: SignalHub = SignalHub.get_instance()
@onready var _analytics: AnalyticsStub = AnalyticsStub.get_instance()

var _current_wave: int = 0

func start_first_wave() -> void:
    _current_wave = 1
    _apply_wave_settings(_current_wave)

func advance_wave() -> void:
    _current_wave += 1
    _apply_wave_settings(_current_wave)

func _apply_wave_settings(wave_index: int) -> void:
    var settings := wave_config.get_settings(wave_index)
    queue.set_spawn_schedule(settings.spawn_schedule)
    queue.set_patience_multiplier(settings.patience_multiplier)
    queue.set_clutter_level(settings.cabinet_clutter_level)
    _analytics.enqueue_wave(settings)
    _signal_hub.wave_settings_applied.emit(settings)
```
Wave settings are applied via typed methods, avoiding runtime lookups and emitting analytics data for telemetry. [Source: architecture/game-data-models.md#game-data-models][Source: architecture/game-systems-components.md#system-interaction-wave-flow][Source: architecture/godot-development-conventions.md#best-practices]

### Implementation Strategy
Keep wave data in `WaveConfig` resources so designers adjust difficulty without code changes, while the controller applies them at runtime. [Source: architecture/node-architecture-details.md#resource-architecture][Source: architecture/game-data-models.md#game-data-models]  
Scale cabinet clutter using pooled descriptors and limit spawn deltas between waves to maintain readability. [Source: architecture/gameplay-systems-architecture.md#gameplay-components][Source: architecture/rendering-pipeline-configuration.md#rendering-optimization]  
Profile each wave via headless tests capturing frame time, ensuring increased density stays within budgets. [Source: architecture/performance-and-security-considerations.md#performance-budgets]

### Tasks / Subtasks
1. **Author WaveConfig Curves (AC: 1)** – Populate spawn cadence, patience multipliers, and clutter levels in resources with designer-reviewed values. [Source: architecture/game-data-models.md#game-data-models]
2. **Implement WaveController (AC: 1, 2)** – Apply settings per wave, emit signals, and integrate with queue and OrderService. [Source: architecture/game-systems-components.md#system-interaction-wave-flow]
3. **Update Cabinet Clutter (AC: 2)** – Expand pooling to support maximum clutter and adjust occlusion culling if needed. [Source: architecture/node-architecture-details.md#node-patterns][Source: architecture/rendering-pipeline-configuration.md#rendering-optimization]
4. **HUD & Analytics (AC: 3, 4)** – Display wave warnings, write analytics payloads, and verify localization. [Source: front-end-spec.md#session_hudtscn][Source: architecture/analytics-integration.md#event-design]
5. **TDD & Profiling (AC: 1–4)** – Write GUT tests for wave transitions, run headless sessions capturing frame/memory metrics, and tweak curves to maintain budgets. [Source: architecture/test-strategy-and-standards.md#godot-test-types-and-organization][Source: architecture/performance-and-security-considerations.md#performance-budgets]

## Testing Requirements
### Unit Tests (TDD Mandatory)
**GUT Test Files (GDScript):**
- `res://tests/gut/unit/test_wave_controller.gd`
- `res://tests/gut/unit/test_wave_config.gd`
- Coverage Target: 80% minimum. [Source: architecture/test-strategy-and-standards.md#godot-test-types-and-organization]

**Test Scenarios (Write First - Red Phase):**
- Controller applies spawn schedule and patience multipliers for each wave. [Source: architecture/game-systems-components.md#core-systems]
- Clutter adjustments respect pool capacity and reuse nodes. [Source: architecture/node-architecture-details.md#node-patterns]
- Analytics payload emits correct wave index and pacing data. [Source: architecture/analytics-integration.md#event-design]

### Game Testing
1. Play through waves 1–3 in editor.  
   - Expected: Spawn cadence accelerates, patience HUD shortens, clutter increases while staying legible. [Source: docs/game-prd/epics/epic-2-progression-and-failstates.md#description][Source: front-end-spec.md#session_hudtscn]  
   - Performance: Maintain ≥60 FPS; record frame time per wave. [Source: architecture/performance-and-security-considerations.md#performance-budgets]
2. Review wave summary overlay and analytics log.  
   - Expected: Difficulty notes display upcoming changes; analytics log includes wave metrics. [Source: architecture/analytics-integration.md#event-design][Source: architecture/ui-component-system.md#data-binding]

### Performance Tests
**Godot Profiler Metrics (Mandatory):**
- Frame rate: 60+ FPS at max clutter (wave 5 stress). [Source: architecture/performance-and-security-considerations.md#performance-budgets]
- Frame time: <16.67 ms average. [Source: architecture/performance-and-security-considerations.md#performance-budgets]
- Physics frame: <4 ms with increased spawn counts. [Source: architecture/physics-configuration.md#physics-settings]
- Memory usage: <1400 MB iOS / 1600 MB Android. [Source: architecture/performance-and-security-considerations.md#performance-budgets]
- Draw calls: <780 under max clutter (update occlusion if higher). [Source: architecture/rendering-pipeline-configuration.md#rendering-optimization]
- Object pools: No new instantiation after wave warmup. [Source: architecture/node-architecture-details.md#node-patterns]
- GDScript static typing verified. [Source: architecture/godot-development-conventions.md#best-practices]
- Analytics flush <10 ms per wave summary. [Source: architecture/analytics-integration.md#implementation]

## Dependencies
**Story Dependencies:**
- 2.1 – Patience Failure Consequences (failure telemetry leverages wave data). [Source: docs/stories/epic-2-progression-and-failstates/2.1-patience-failure-consequences.md]
- Epic 1 stories provide queue, solver, and scoring baseline. [Source: docs/stories/epic-1-core-order-fulfillment-loop/1.4-order-resolution-scoring-and-reset.md]

**Godot System Dependencies:**
- Node: `SessionRoot` must host `WaveController`, `CustomerQueue`, `CabinetItemPool`, `OrderService`, `AnalyticsStub`. [Source: architecture/high-level-architecture.md#high-level-overview]
- Autoload: `WaveController` (if autoloaded), `OrderService`, `SignalHub`, `GameState`. [Source: architecture/game-systems-components.md#core-systems]
- Language: Typed GDScript enforced. [Source: architecture/godot-development-conventions.md#workflow-conventions]

**Resource Dependencies:**
- Resource Type: `.tres`
- Asset: `wave_config.tres`, `clutter_profiles.tres`, `spawn_curves.tres`
- Location: `res://resources/data/`, `res://resources/curves/`
- Import Settings: Maintain curve precision and document version tags. [Source: architecture/node-architecture-details.md#resource-architecture]

## Definition of Done
- All acceptance criteria met. [Source: docs/game-prd/epics/epic-2-progression-and-failstates.md#stories]
- TDD followed (tests written first, then implementation). [Source: architecture/test-strategy-and-standards.md#testing-philosophy]
- GUT tests passing with 80%+ coverage. [Source: architecture/test-strategy-and-standards.md#testing-philosophy]
- GoDotTest passing (if applicable). [Source: architecture/test-strategy-and-standards.md#godot-test-types-and-organization]
- Performance: 60+ FPS maintained. [Source: architecture/performance-and-security-considerations.md#performance-budgets]
- Static typing used in all GDScript. [Source: architecture/godot-development-conventions.md#best-practices]
- Object pooling active for clutter. [Source: architecture/node-architecture-details.md#node-patterns]
- Signals properly connected and cleaned up. [Source: architecture/game-systems-components.md#system-interaction-wave-flow]
- No GDScript warnings. [Source: architecture/godot-development-conventions.md#workflow-conventions]
- Node hierarchy conforms to architecture. [Source: architecture/high-level-architecture.md#high-level-overview]
- Resources configured and versioned. [Source: architecture/node-architecture-details.md#resource-architecture]
- Export templates tested. [Source: architecture/core-game-workflows.md#core-game-workflows]
- Documentation updated. [Source: architecture/core-game-workflows.md#core-game-workflows]
- Wave telemetry validated in analytics log. [Source: architecture/analytics-integration.md#implementation]

## Notes
**Godot Implementation Notes:**
- Language Choice: GDScript adheres to single-language strategy while enabling fast iteration. [Source: architecture/godot-development-conventions.md#best-practices]
- Node Architecture: `WaveController` sits near `OrderService` and `CustomerQueue` for direct coordination. [Source: architecture/high-level-architecture.md#high-level-overview]
- Signal Pattern: Wave signals propagate through `SignalHub` to HUD and analytics for loose coupling. [Source: architecture/game-systems-components.md#system-interaction-wave-flow]
- Designer curves stored in resources for quick tuning. [Source: architecture/node-architecture-details.md#resource-architecture]

**Performance Decisions:**
- Static Typing: Mandatory for wave logic to minimize allocations. [Source: architecture/godot-development-conventions.md#best-practices]
- Object Pooling: Clutter uses pooled descriptors to avoid instantiation spikes. [Source: architecture/node-architecture-details.md#node-patterns]
- Precomputed spawn schedules loaded once per wave to reduce CPU overhead. [Source: architecture/performance-and-security-considerations.md#performance-budgets]
- Analytics flush occurs after wave summary to avoid interfering with gameplay. [Source: architecture/analytics-integration.md#implementation]

**Future Optimizations:**
- Integrate adaptive difficulty toggles once telemetry identifies churn points. [Source: docs/game-prd/epics/epic-2-progression-and-failstates.md#risks--mitigations]
- Add editor tool for visualizing wave curves. [Source: architecture/node-architecture-details.md#resource-architecture]
- Evaluate lazy-loading alternate clutter meshes for seasonal updates. [Source: architecture/rendering-pipeline-configuration.md#rendering-optimization]
