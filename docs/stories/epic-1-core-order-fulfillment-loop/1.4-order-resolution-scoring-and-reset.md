# Godot Story: Order Resolution, Scoring & Reset

**Epic:** Epic 1 – Core Order Fulfillment Loop  
**Story ID:** 1.4  
**Priority:** High  
**Points:** 5  
**Status:** Draft  
**Language:** GDScript  
**Performance Target:** 60+ FPS

## Description
Wire the completion of claw interactions into scoring, life management, and queue reset so each order results in consistent feedback, telemetry, and cabinet cleanup. The workflow consumes solver callbacks, applies combo math, decrements lives on failure, and primes the next cat while keeping HUD and analytics in sync. [Source: game-prd/requirements.md#functional][Source: architecture/game-systems-components.md#core-systems][Source: architecture/analytics-integration.md#implementation]

**Godot Implementation:** Extend `OrderService`, `GameState`, and `SessionHUD` controllers with typed signals that update score, combo, lives, and wave progress, then recycle cabinet entities through pooling. [Source: architecture/gameplay-systems-architecture.md#gameplay-overview][Source: architecture/high-level-architecture.md#high-level-overview][Source: architecture/ui-component-system.md#component-library]

**Performance Impact:** Perform resolution logic off the main physics loop via deferred calls, reuse pooled nodes, and batch HUD updates to stay under the 16.67 ms frame budget. [Source: architecture/performance-and-security-considerations.md#performance-budgets][Source: architecture/ui-component-system.md#data-binding][Source: architecture/node-architecture-details.md#node-patterns]

## Acceptance Criteria
### Functional Requirements
- Successful grabs trigger `OrderService.resolve_success`, awarding score, combo multipliers, and wave progress updates while `SessionHUD` reflects changes within one frame. [Source: architecture/game-systems-components.md#core-systems][Source: front-end-spec.md#session_hudtscn][Source: game-prd/requirements.md#functional]
- Failures (patience expiry or wrong item) decrement lives, play failure cues, log analytics, and enqueue the next cat with reset patience. [Source: architecture/game-systems-components.md#system-interaction-wave-flow][Source: architecture/audio-architecture.md#system-design][Source: architecture/analytics-integration.md#event-design]
- Cabinet contents and claw state reset via pooled nodes before the next patron appears, guaranteeing no leftover grabbed items. [Source: architecture/node-architecture-details.md#node-patterns][Source: architecture/gameplay-systems-architecture.md#gameplay-components]
- Telemetry events (`order_fulfilled`, `order_failed`) capture combo, time remaining, and wave index for analytics. [Source: architecture/analytics-integration.md#event-design]

### Technical Requirements
- Code follows typed GDScript best practices with deferred HUD updates to avoid blocking `_process`. [Source: architecture/godot-development-conventions.md#best-practices][Source: architecture/ui-component-system.md#data-binding]
- Maintains 60+ FPS on all target devices (frame time <16.67 ms). [Source: architecture/performance-and-security-considerations.md#performance-budgets]
- Object pooling reused for seafood, VFX, and cat reaction assets. [Source: architecture/node-architecture-details.md#node-patterns]
- Signals properly connected and cleaned up after each order cycle. [Source: architecture/game-systems-components.md#core-systems]
- GUT coverage ≥ 80%. [Source: architecture/test-strategy-and-standards.md#testing-philosophy]
- Analytics writes stay asynchronous to avoid stalling the main thread. [Source: architecture/analytics-integration.md#implementation]

### Game Design Requirements
- Score, combo, and life indicators animate per UX spec without obscuring gameplay. [Source: front-end-spec.md#session_hudtscn][Source: front-end-spec.md#fulfill-customer-order-during-score-run]
- Cat reaction portraits and VO/haptics reflect success/failure states. [Source: architecture/audio-architecture.md#system-design][Source: game-prd/requirements.md#functional]
- Tutorial hints remain visible until the next order arrives, ensuring clarity for new players. [Source: front-end-spec.md#fulfill-customer-order-during-score-run][Source: architecture/ui-component-system.md#component-library]

## Technical Specifications
### Files to Create/Modify
**New Scripts:**
- `res://scripts/services/order_resolution_pipeline.gd` – Coordinates solver callbacks, scoring math, analytics, and queue reset steps. [Source: architecture/game-systems-components.md#core-systems][Source: architecture/analytics-integration.md#implementation]
- `res://scripts/ui/session_score_panel.gd` – Handles score/combo animations with deferred batching. [Source: front-end-spec.md#session_hudtscn][Source: architecture/ui-component-system.md#data-binding]

**Modified Files:**
- `res://autoload/OrderService.gd` – Add success/failure resolution APIs, combo tracking, and analytics emission. [Source: architecture/game-systems-components.md#core-systems]
- `res://autoload/GameState.gd` – Update life totals, wave progression, and send pause-safe state changes. [Source: architecture/game-systems-components.md#core-systems]
- `res://autoload/SignalHub.gd` – Register `order_resolved`, `order_failed`, and `score_updated` signals. [Source: architecture/game-systems-components.md#system-interaction-session-core]
- `res://scripts/ui/session_hud.gd` – Consume resolution signals, animate score widgets, and batch UI updates. [Source: front-end-spec.md#session_hudtscn][Source: architecture/ui-component-system.md#data-binding]
- `res://scripts/gameplay/customer_queue.gd` – Listen for resolution events to spawn the next cat and recycle the previous avatar. [Source: architecture/gameplay-systems-architecture.md#gameplay-components]
- `res://scripts/services/analytics_stub.gd` – Append order resolution payloads and flush queue at wave boundaries. [Source: architecture/analytics-integration.md#implementation]

### Node/Class Definitions
**GDScript Implementation (for game logic):**
```gdscript
# order_resolution_pipeline.gd
class_name OrderResolutionPipeline
extends Node

@onready var _order_service: OrderService = OrderService.get_instance()
@onready var _game_state: GameState = GameState.get_instance()
@onready var _analytics: AnalyticsStub = AnalyticsStub.get_instance()
@onready var _signal_hub: SignalHub = SignalHub.get_instance()

func resolve_success(result: OrderResult) -> void:
    _order_service.apply_combo(result)
    _game_state.add_score(result.score_awarded)
    _signal_hub.score_updated.emit(_game_state.score, _game_state.combo)
    _enqueue_analytics(&"order_fulfilled", result)
    _prepare_next_order()

func resolve_failure(result: OrderResult) -> void:
    _game_state.decrement_life()
    _signal_hub.order_failed.emit(result)
    _enqueue_analytics(&"order_failed", result)
    _prepare_next_order()
```
The pipeline centralizes resolution logic, updates stateful services, and emits analytics events without blocking gameplay. [Source: architecture/game-systems-components.md#system-interaction-session-core][Source: architecture/analytics-integration.md#implementation][Source: architecture/godot-development-conventions.md#best-practices]

### Implementation Strategy
Route all solver callbacks into `OrderResolutionPipeline` to keep scoring logic isolated and easily testable. [Source: architecture/gameplay-systems-architecture.md#gameplay-components]  
Batch HUD updates by deferring UI updates through `UIManager` so combo/score animations can play without frame spikes. [Source: architecture/ui-component-system.md#data-binding][Source: front-end-spec.md#session_hudtscn]  
Emit analytics events asynchronously and flush on wave boundaries to honor the offline logging strategy. [Source: architecture/analytics-integration.md#implementation]

### Tasks / Subtasks
1. **Extend OrderService DTOs (AC: 1)** – Capture combo, time remaining, and descriptor data needed for scoring. [Source: architecture/game-data-models.md#game-data-models][Source: architecture/game-systems-components.md#core-systems]
2. **Implement Resolution Pipeline (AC: 1, 2)** – Build success/failure handlers, update GameState, and publish signals to HUD/Queue. [Source: architecture/game-systems-components.md#system-interaction-session-core]
3. **Update HUD & Audio Hooks (AC: 1, 2, 3)** – Animate score widgets, trigger reaction VFX/audio, and ensure localization remains intact. [Source: front-end-spec.md#session_hudtscn][Source: architecture/audio-architecture.md#system-design]
4. **Analytics & Telemetry (AC: 2, 4)** – Append events to AnalyticsStub and verify payload contents; add tests for queue flushing. [Source: architecture/analytics-integration.md#implementation]
5. **TDD & Profiling (AC: 1–4)** – Write GUT tests for scoring math, failure paths, and queue reset; capture profiler snapshot confirming HUD updates avoid layout thrash. [Source: architecture/test-strategy-and-standards.md#godot-test-types-and-organization][Source: architecture/performance-and-security-considerations.md#performance-budgets]

## Testing Requirements
### Unit Tests (TDD Mandatory)
**GUT Test Files (GDScript):**
- `res://tests/gut/unit/test_order_resolution_pipeline.gd`
- `res://tests/gut/unit/test_game_state_scoring.gd`
- Coverage Target: 80% minimum with fixtures for success/failure payloads. [Source: architecture/test-strategy-and-standards.md#godot-test-types-and-organization]

**Test Scenarios (Write First - Red Phase):**
- Success resolution increases score and combo per combo table. [Source: architecture/game-systems-components.md#core-systems]
- Failure path decrements life, resets combo, and schedules next order. [Source: architecture/gameplay-systems-architecture.md#gameplay-components]
- Analytics payload contains `wave`, `combo`, `time_remaining`, and `fish_type`. [Source: architecture/analytics-integration.md#event-design]

### Game Testing
1. Run three orders in editor (success, failure, success).  
   - Expected: Score/combo HUD updates instantly; failure plays VO/haptic cues; next cat spawns with reset patience. [Source: front-end-spec.md#fulfill-customer-order-during-score-run][Source: architecture/audio-architecture.md#system-design]  
   - Performance: Maintain ≥60 FPS with batched HUD updates. [Source: architecture/performance-and-security-considerations.md#performance-budgets]
2. Inspect analytics log and HUD after wave completion.  
   - Expected: Two entries (`order_fulfilled`, `order_failed`) with accurate payloads; HUD reflects final score/lives; queue reset ready for next wave. [Source: architecture/analytics-integration.md#implementation][Source: architecture/game-systems-components.md#system-interaction-wave-flow]

### Performance Tests
**Godot Profiler Metrics (Mandatory):**
- Frame rate: 60+ FPS while resolving rapid back-to-back orders. [Source: architecture/performance-and-security-considerations.md#performance-budgets]
- Frame time: <16.67 ms average even when combo animations trigger. [Source: architecture/performance-and-security-considerations.md#performance-budgets]
- Physics frame: <4 ms (resolution occurs outside physics). [Source: architecture/physics-configuration.md#physics-settings]
- Memory usage: <1400 MB iOS / 1600 MB Android. [Source: architecture/performance-and-security-considerations.md#performance-budgets]
- Draw calls: <720 including HUD animations. [Source: architecture/rendering-pipeline-configuration.md#rendering-optimization]
- Object pools: Customer avatars and seafood remain within preallocated pool sizes. [Source: architecture/node-architecture-details.md#node-patterns]
- GDScript static typing: Verified via lint/test run. [Source: architecture/godot-development-conventions.md#best-practices]
- Analytics queue flush completes asynchronously within 10 ms budget. [Source: architecture/analytics-integration.md#implementation]

## Dependencies
**Story Dependencies:**
- 1.1 – Customer Queue & Order Announcements: supplies queue spawn/reset behavior. [Source: docs/stories/epic-1-core-order-fulfillment-loop/1.1-customer-queue-and-order-announcements.md]
- 1.2 – Order Visualization & Cabinet Highlighting: ensures visual state clears after resolution. [Source: docs/stories/epic-1-core-order-fulfillment-loop/1.2-order-visualization-and-cabinet-highlighting.md]
- 1.3 – Claw Rig Control & Physics Integration: provides solver callbacks for success/failure. [Source: docs/stories/epic-1-core-order-fulfillment-loop/1.3-claw-rig-control-and-physics-integration.md]

**Godot System Dependencies:**
- Node: `SessionRoot` instantiates `OrderService`, `GameState`, `SessionHUD`, `CustomerQueue`, and autoloaded analytics stub. [Source: architecture/high-level-architecture.md#high-level-overview]
- Autoload: `OrderService`, `GameState`, `SignalHub`, `AnalyticsStub`, `AudioDirector`. [Source: architecture/game-systems-components.md#core-systems]
- Language: Typed GDScript enforced with static typing. [Source: architecture/godot-development-conventions.md#workflow-conventions]

**Resource Dependencies:**
- Resource Type: `.tres`
- Asset: `combo_curve.tres`, `wave_schedule.tres`, `analytics_config.tres`
- Location: `res://resources/data/`
- Import Settings: Validate curve precision and ensure analytics schema version tag stored in metadata. [Source: architecture/node-architecture-details.md#resource-architecture]

## Definition of Done
- All acceptance criteria met. [Source: game-prd/epics/epic-1-core-order-loop.md#stories]
- TDD followed (tests written first, then implementation). [Source: architecture/test-strategy-and-standards.md#testing-philosophy]
- GUT tests passing (GDScript) with 80%+ coverage. [Source: architecture/test-strategy-and-standards.md#testing-philosophy]
- GoDotTest passing (C#) with 80%+ coverage (N/A if unused). [Source: architecture/test-strategy-and-standards.md#godot-test-types-and-organization]
- Performance: 60+ FPS maintained on all platforms. [Source: architecture/performance-and-security-considerations.md#performance-budgets]
- Static typing used in all GDScript. [Source: architecture/godot-development-conventions.md#best-practices]
- Object pooling active for reusable entities. [Source: architecture/node-architecture-details.md#node-patterns]
- Signals properly connected and cleaned up. [Source: architecture/game-systems-components.md#core-systems]
- No GDScript warnings. [Source: architecture/godot-development-conventions.md#workflow-conventions]
- Node hierarchy follows architecture. [Source: architecture/high-level-architecture.md#high-level-overview]
- Resources configured properly. [Source: architecture/node-architecture-details.md#resource-architecture]
- Export templates tested. [Source: architecture/core-game-workflows.md#core-game-workflows]
- Documentation updated. [Source: architecture/core-game-workflows.md#core-game-workflows]
- Analytics events validated in log output. [Source: architecture/analytics-integration.md#implementation]

## Notes
**Godot Implementation Notes:**
- Language Choice: GDScript keeps scoring logic close to existing services for rapid iteration with static typing. [Source: architecture/godot-development-conventions.md#best-practices]
- Node Architecture: Pipeline node attached to `SessionRoot` for direct access to autoloads while remaining testable. [Source: architecture/high-level-architecture.md#high-level-overview]
- Signal Pattern: Use `SignalHub` for all order resolution notifications to keep queue, HUD, and analytics decoupled. [Source: architecture/game-systems-components.md#system-interaction-session-core]
- Analytics integration stays offline-friendly using the stubbed queue. [Source: architecture/analytics-integration.md#implementation]

**Performance Decisions:**
- Static Typing: Enforce typed GDScript on scoring classes for 10–20 % gain. [Source: architecture/godot-development-conventions.md#best-practices]
- C# Usage: Not required; scoring remains in GDScript to avoid marshalling. [Source: architecture/game-systems-components.md#core-systems]
- Object Pooling: Recycle cat avatars, seafood, and VFX nodes through existing pools. [Source: architecture/node-architecture-details.md#node-patterns]
- HUD batching uses deferred calls to prevent layout thrash. [Source: architecture/ui-component-system.md#data-binding]

**Future Optimizations:**
- Add heat-map logging for combo streaks to aid balancing. [Source: architecture/analytics-integration.md#event-design]
- Evaluate dynamic difficulty adjustments once Epic 2 scaling is online. [Source: architecture/gameplay-systems-architecture.md#gameplay-overview]
- Consider porting scoring math to C# if future waves introduce heavy computations. [Source: architecture/game-systems-components.md#core-systems]
